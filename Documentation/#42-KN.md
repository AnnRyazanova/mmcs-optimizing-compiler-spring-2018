### Название задачи
Удаление мертвого кода между базовыми блоками

#### Зависит от:
* Def/Use Lists
* LiveAndDead Variables
* Delete Dead Code In Single Block
* Def/Use Sets
* Iteractive Algorithm For Active Variables

#### Теоретическая часть задачи
На вход поступает код программы, на выходе код с удаленными строками (мертвыми).
Значит, для нашего кода мы строим граф всей программы.
После этого для такого графа мы применяем итерационный алгоритм и получаем OUT-переменные.
Далее для каждого блока в этом графе мы удаляем строки мертвого кода следующим образом:
подается блок, для него мы вычисляем живые/мертвые переменные. Также для нашего блока были
посчитаны OUT-переменные с помощью итерационного алгоритма. Мы делаем следущее, если в списке
мертвых переменных встретилась переменная, которая является out (т.е. нужна другому блоку в 
программе), то мы находим последнее присваивание этой переменной и перемещаем его в
список живых переменных. После все строки с мертвыми переменными мы удаляем. Теперь получается 
необходимо удалить код, который был удален алгоритмом из исходного кода программы. Это делается 
алгоритмом замещения кода: идея состоит в том, что мы имеем исходный блок В и измененный блок без мертвого 
кода Т. Мы хотим найти в исходном блоке вхождение блока В и заменить его на вхождение блока Т.
После этого мы строим граф для нашего нового кода и повторяем все шаги, пока на каком-то этапе
мы не удалим ни одной строчки кода.

#### Входные данные
Код программы в трехадресном виде

#### Входные данные
Код программы в трехадресном виде без мертвых строк кода

#### Реализация
Ниже приведена часть алгоритма:
```csharp
     /// <summary>
        /// Удаление мертвого кода в CFG
        /// </summary>
        /// <returns></returns>
        private TACode RemoveDeadCodeInCFG()
        {
            var code = new TACode();
            code.CodeList = CodeIN.CodeList.ToList();
            ControlFlowGraph cfg;
            int countRemove;

            do
            {
                // Вычисляем CFG
                cfg = new ControlFlowGraph(code);
                // Вычисляем IN и OUT переменные для всех блоков в CFG
                this.OUT = (new IterativeAlgorithmAV(cfg)).OUT;
                countRemove = 0;

                // Для каждого блока в cfg
                foreach (var B in cfg.CFGNodes)
                {
                    // Удаляем мертвые строки кода
                    var newB = RemoveDeadCodeInBlock(B);
                    var curCountRem = B.CodeList.Count() - newB.CodeList.Count();

                    if (curCountRem != 0)
                    {
                        var idxStart = CalculateIdxStart(B, code.CodeList);
                        var len = B.CodeList.Count();
                        code = ReplaceCode(code, newB.CodeList.ToList(), idxStart, len);
                        countRemove += curCountRem;
                    }
                }
            }
            while (countRemove != 0);

            return code;
        }
```
#### Тесты
```csharp
Исходный код:
// 0:       a = 2
// 1:       b = 3
// 2: (1) : c = a + b
// 3: (2) : a = 3
// 4:       b = 4
// 5: (3) : c = a
// 6:       print(c)

Результат:
// 0: (2) : a = 3
// 1: (3) : c = a
// 2:       print(c)
```            
